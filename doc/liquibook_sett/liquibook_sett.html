
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="description" content="Building a Market Data Feed with Liquibook"/>
    <meta name="keywords" content="SETT, OCI, (more article keywords here)"/>
    <meta name="author" content="Jeff Schmitz"/>
    <title>SETT August 2013 &mdash; Building a Market Data Feed with Liquibook</title>

    <link href="styles/SETT.css" rel="stylesheet" type="text/css"/>
    <link href="settAug2013_files/paper.css" rel="stylesheet" type="text/css"/>

    <!--Used for syntax highlighting.  -->
    <link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css"/>
    <link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="header">
    <div>
        <div style="float: left">
            <a href="http://twitter.com/ObjectComputing" class="twitter-follow-button">Follow @ObjectComputing</a>
        </div>
        <div class="quicklinks" style="float:right">
            <a href="http://www.ociweb.com/">Home</a> |
            <a href="http://www.ociweb.com/sett/index.html"> Software Engineering Tech Trends Archive</a> |
            <a href="#ocieducationalservices">OCI Educational Services</a>
        </div>
    </div>
    <table cellpadding="0" cellspacing="0" width="100%" border="0">
        <tbody>
        <tr>
            <td><a href="http://www.ociweb.com/"><img alt="" src="images/OCILogo.png" height="120" width="180"/></a>
            </td>
            <td><img alt="" src="images/Left.png" height="58" width="10"/></td>
            <td style="width:100%"><img alt="" src="images/Middle.png" height="58" width="100%"/></td>
            <td><img alt="" src="images/Right.png" height="58" width="278"/></td>
        </tr>
        </tbody>
    </table>
    <div>
        <hr/>
        <div style="float:left">
            <img alt="" src="images/SETT.png" height="34" width="377"/>
        </div>
        <div style="float:right">
            <!-- AddThis Button BEGIN -->
<div class="addthis_toolbox addthis_default_style">
    <!--<a class="addthis_button_rss_follow" addthis:userid="sett.ociweb.com/sett"></a>-->
    <a class="addthis_button_tweet"></a>
    <a id="plusone" class="addthis_button_google_plusone"></a>
    <a class="addthis_button_dzone"></a>
    <a class="addthis_button_reddit"></a>
    <a class="addthis_button_digg"></a>
    <a id="addthis" class="addthis_counter addthis_pill_style"></a>
</div>
<script type="text/javascript">
    document.getElementById("plusone").setAttribute("g:plusone:size", "medium");
    document.getElementById("addthis").setAttribute("addthis:ui_delay", "500");
</script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-51702ff71314f8ed"></script>
<!-- AddThis Button END -->

        </div>
        <br/>
        <br/>
    </div>
</div>


<h1>Building a Market Data Feed with Liquibook</h1>

<p class="author">
    by<br/>

    Jeff Schmitz, Principal Software Engineer
    <br/>Object Computing, Inc. (OCI)
</p>

<h2>Introduction</h2>

<p>
  The financial industry relies heavily on systems to disseminate and interpret
  market data. Both trading decisions and analytics are based on the current
  state of the market for a particular security.  A typical trading exchange
  involves multiple partries, and in a conceptual view looks like this:
</p>

<img src="settAug2013_files/Exchange.png"/>

<p>
  Building such an exchange is a complex undertaking, involving order taking,
  matching, compression, dissemination, decompression, and interpretation. 
  This paper will demonstrate how to build such a system using only open-source
  components, including Liquibook for limit order book matching, QuickFAST for
  compression and decompression, and Boost ASIO for distribution.
</p>

<h2>Liquibook Background</h2>

<p>
  Liquibook is a C++ open source limit order book matching engine.  It is a
  component library that you can integrate into your project for implementing
  matching algorithms.  Liquibook includes compoenents for an order book,
  aggregate depth tracking, BBO tracking, and a trade feed.
</p>

<h2>QuickFAST Background</h2>

<p>
  The FAST protocol is a compression and encoding mechanism for streaming data.
  QuickFAST is an impelementation of the FAST protocol in C++ for encoding and 
  decoding message streams using the FAST protocol.
</p>

<h2>Boost ASIO Background</h2>

<p>
  Boost ASIO is a cross-platform C++ library for asynchronous network
  programming.
</p>

<h2>Example System</h2>

<p>
  The example project for this paper will take on a more advanced use case - 
  simulating an exchange producing a 5-level depth feed, aggregated by price,
  and a trade feed.
</p>

<p>  
  This example involves a number of steps:
</p>

<h3>Accept Orders</h3>

<p>
  The example exchange generates orders, simulating the receipt of orders from
  traders.  A true exchange takes orders from traders by means of an API - 
  often via the FIX protocol.  For the purposes of this paper, internally
  generated orders will suffice.
</p>

<h3>Maintain a Limit Order Book of all Unfilled Orders for Each Security</h3>

<p>
  The example exchange must be ready to match unfilled orders against inbound
  orders.  This is done by means of a limit order book.  The limit order book
  keeps these orders sorted so that when multiple existing orders can match a
  new inbound order, the matching is performed in a sequence determined by
  established exchange rules.  The example exchange uses Liquibook's OrderBook
  class to maintain the limit order book.
</p>

<h3>Match Buy and Sell Orders</h3>

<p>
  The example exchange must match new inbound orders against those in the 
  limit order book.  The exchange must detect a match, and fill the appropriate 
  orders.  Liquibook's OrderBook class naturally includes matching capability.
</p>

<h3>Update Trading Client Order Status</h3>

<p>
  A real exchange must always notify traders of changes in their order status.
  This includes accepting, filling, and rejecting, orders, but also accepting
  or rejecting an order cancellation or replacement requests.  In the example
  exchange, this will be skipped because there are no trading clients - the
  orders are randomly generated.  Liquibook does, however, provide an interface
  and make callbacks for changes in order status, which can easily be turned
  into notifications sent to trading clients.
</p>

<h3>Aggregate the Top 5 Price Levels into Depth</h3>

<p>
  While a full order book feed is useful, some markets choose to send 
  aggregated forms of data instead, known as depth.  Rather than
  representing individual orders, the depth models price levels as a whole.
  The market will also limit the number of levels distributed - top 5 and 
  top 10 are common limits.  
</p>
<p>
  The example exchange goes through the extra step and complexity of building
  5-level depth.  Liquibook provides the DepthOrderBook class, which
  manages the order book and depth, and the DepthListener class for being
  notified of changes to the top few depth levels.
</p>

<h3>Determine Changes to Depth in Response to an Event</h3>

<p>
  It is not enough to maintain the depth.  In order to produce an 
  incremental feed, the example exchange must also be able to determine which
  levels of the depth have changed.  A change can happen to one or more
  levels in the depth, on both the buy and sell sides, in response to a
  single order event.  Liquibook has an interface for interrogating the various
  levels of depth and finding out if it has changed since the last
  published change.  This makes it trival to build an incremental feed -
  sending only changed levels to feed clients.
</p>

<h3>Compress and Distributing Market Data in a Feed</h3>

<p>
  In order to effectively trade, feed clients have a need to understand order
  flow in the exchange.  Feeds in which clients are norified of all possible
  order detail are known as "quote" feeds or "full order book" feeds.  The
  example exchange, however, summarizes the order book using dept.  It 
  notifies feed clients of trades and changes in the depth.  Liquibook supports
  building a trade feed through the TradeListener inteface, and a depth feed
  through the DepthListener class.  It also supports building a full order book
  feed, through the OrderListener class.
</p>

<p>
  The example exchange then compresses the trade and depth messages using
  QuickFAST and sends them to clients using Boost ASIO.
</p>

<h3>Handle the Feed in a Client Program</h3>

<p>
  Finally, the example includes feed clients that connect to the feed, and 
  decodes the updates (in the FAST protocol), and recreates the trade events 
  and the market depth.  The clients use QuickFAST for decoding, and Boost ASIO
  to handle network I/O.
</p>

<h2>Getting Started</h2>

<p>
  If you intend to build this project, you will need to download and build:
</p>

<ol>
  <li>Boost version 1.53 or later</li>
  <li>Xerces version 3.1.1 or later</li>
  <li>QuickFAST version <b>1.5.0 or later</b></li>
  <li>Liquibook version <b>1.1</b> or later </li>
</ol>

<p>
  The project is found in total within the directory
  <code> examples/depth_feed_publisher</code> of Liquibook.
</p>

<h2>The Example Exchange</h2>

<p>
  The example exchange consists of two applications, a publisher and a
  subscriber.  The figure below illustrates the flow of data in the example
  exchange.
</p>

<img src="settAug2013_files/ExampleExchange.png"/>

<h2>Publisher Application</h2>

<p>
  The publisher acts as the exchange in the example project.  The publisher is 
  therefore responsible for maintaining the various order books (one per
  security), building the feed messages, and publishing the messages, in a
  FAST-encoded format.
</p>

<p>
  The publisher also simulates the trading clients, generating random orders
  inside the process, and adding them to the appropriate order book.
</p>

<p>
  Finally, the publisher will listen for network connections from one or more
  subscribers.
</p>

<h3>Order Class</h3>

<p>
  Liquibook requires that the application define an order class to represent 
  an order to match.  Liquibook requires that it meet the interface defined
  in the class <code>src/book/order.h</code>, which includes the conversion
  of the order's price to integer format.
</p>

<div class="listing">Listing 1 book/order.h: Order class of Liquibook</div>
<pre class="code">
namespace liquibook { namespace book {

class Order {
public:
  /// @brief is this a limit order?
  bool is_limit() const;

  /// @brief is this order a buy?
  virtual bool is_buy() const = 0;

  /// @brief get the price of this order, or 0 if a market order
  virtual Price price() const = 0;

  /// @brief get the quantity of this order
  virtual Quantity order_qty() const = 0;
};

} }
</pre>

<h2>Subscriber Application</h2>
<p>
  There is also one or more subscribers, who are responsible for decoding the
  FAST messages and displaying the results in the console.  The publisher
  listens for connections, and the subscribers connect to the publisher.
</p>

</p>

<p>
  Liquibook accepts pointers to orders in the API for order books, and 
  provides those pointers back in callbacks.  A client program can extend the
  order interface to add whatever additional information is needed in the
  callbacks.  The order class for the example exchange looks like this:
</p>

<div class="listing">Listing 2 order.h: Implementation of Order class in example exchange</div>
<pre class="code">
namespace liquibook { namespace examples {

class Order : public book::Order {
public:
  Order(bool buy,
        const double&amp; price,          
        book::Quantity qty);

  virtual bool is_buy() const;
  virtual book::Price price() const;
  virtual book::Quantity order_qty() const;
private:
  bool is_buy_;
  double price_;
  book::Quantity qty_;

  static const uint8_t precision_;
};

} }
</pre>

<p>
  The example exchange's order class inherits from <code>book::Order</code>
  and implements its 3 pure virtual functions.  Inheriting from the 
  <code>book::Order</code> class is not strictly necessary as the rest of 
  Liquibook uses templates to bind to a specific order class.  The trivial 
  implementation of this class is omitted from this paper.
</p>

<h3>The Order Book</h3>

<p>
  Liquibook comes with an order book class - two actually:
  <code>book::OrderBook</code> for managing an order book only, and a derived
  class <code>book::DepthOrderBook</code> for adding depth aggregation to that
  order book.  Since this example builds a depth feed, it uses
  <code>book::DepthOrderBook</code>.  The important parts of the 
  <code>book::OrderBook</code> class are:
</p>

<div class="listing">Listing 3 book/order_book.h: OrderBook class of Liquibook</div>
<pre class="code">
namespace liquibook { namespace book {

template &lt;class OrderPtr = Order*&gt;
class OrderBook {
public:
  typedef OrderBook&lt;OrderPtr &gt; MyClass;
  typedef TradeListener&lt;MyClass &gt; TypedTradeListener;

  /// @brief set the trade listener
  void set_trade_listener(TypedTradeListener* listener);

  /// @brief add an order to book
  /// @param order the order to add
  /// @param conditions special conditions on the order
  /// @return true if the add resulted in a fill
  virtual bool add(const OrderPtr& order, OrderConditions conditions = 0);

  /// @brief perform all callbacks in the queue
  virtual void perform_callbacks();
};

} }
</pre>

<p>
  Note that the <code>book::OrderBook</code> class is a template class, allowing
  the user to define not only the order class used in the order book, but the 
  style of pointer used.  This can be a regular pointer or a smart pointer.  The  example exchange uses a <code>boost::shared_ptr</code>.
</p>

<p>
  The first method of interest allows a setting of a listener for trades.  This
  listener, shown later, gets notified when a trade occurs.  The example
  exchange needs this notification to build a trade feed, and thus sets the
  trade listener.  The <code>book::OrderBook</code> class also includes
  listeners for all order status updates, for providing updates back to the
  trade clients, and a listener for all changes to the order book, to build a
  full order book feeed.
</p>

<p>
  Next is a method to add an order to the order book.  <code>add()</code> 
  accepts an order pointer, and condition flags for special conditions, like
  an immediate or cancel order.  Note that there are also methods (not used in
  the example exchange) to cancel an order and to replace an order.
</p>

<p>
  Finally, there is a method to perform the callbacks on the order book.  The
  client code is responsible for calling this method.  In that way, it can
  decide whether it is done in the calling thread, or in a background thread.
  By default, this method calls <code>perform_callback()</code> for each
  callback in the queue.  Naturally, <code>perform_callback()</code> can be
  overridden.  The default implementation of this method issues callbacks for
  to the trade listener, order listener, and order book listener, if present.
</p>

<p>
  The <code>book::DepthOrderBook</code> class is simpiler:
</p>

<div class="listing">Listing 4 book/depth_order_book.h: DepthOrderBook class of Liquibook</div>
<pre class="code">
namespace liquibook { namespace book {

/// @brief Implementation of order book child class, that incorporates
///        aggregate depth tracking.  Overrides perform_callback() method to 
//         track depth aggregated by price.
template <class OrderPtr = Order*, int SIZE = 5>
class DepthOrderBook : public OrderBook<OrderPtr> {
public:
  typedef Depth<SIZE> DepthTracker;
  typedef BboListener<DepthOrderBook >TypedBboListener;
  typedef DepthListener<DepthOrderBook >TypedDepthListener;
  typedef Callback<OrderPtr> DobCallback;

  /// @brief construct
  DepthOrderBook();

  /// @brief set the BBO listener
  void set_bbo_listener(TypedBboListener* bbo_listener);

  /// @brief set the depth listener
  void set_depth_listener(TypedDepthListener* depth_listener);

  /// @brief handle a single callback
  virtual void perform_callback(DobCallback& cb);

  // @brief access the depth tracker
  DepthTracker& depth();

  // @brief access the depth tracker
  const DepthTracker& depth() const;

private:
  DepthTracker depth_;
  TypedBboListener* bbo_listener_;
  TypedDepthListener* depth_listener_;
};
</pre>

<p>
  <code>book::DepthOrderBook</code> overrides <code>perform_callback()</code>
  to update the depth, which is accessible through the <code>depth()</code>
  methods.
</p>

<p>
  In addition, <code>book::DepthOrderBook</code> adds two new listeners -
  a BBO listener, for tracking only changes to the best bid and best offer, and 
  a depth listener, for tracking all depth changes.
</p>

<p>
  To build the example exchange, a <code>book::DepthOrderBook</code> must be
  used, and it must have a trade listener and a depth listener set.  In these
  listener's callbacks, the feed clients must be updated with trade and depth
  update messages.
</p>

<p>
  In some of these callbacks, a pointer to the order book is provided.  This
  gives the client code the opportunity to derive from one of the order book
  classes, and add custom fields.  The example exchange takes advantage of this,
  providing access to the symbol of the order book's security:
</p>

<div class="listing">Listing 5 example_order_book.h: ExampleOrderBook class in example exchange</div>
<pre class="code">
namespace liquibook { namespace examples {

typedef boost::shared_ptr<Order> OrderPtr;

class ExampleOrderBook : public book::DepthOrderBook<OrderPtr> {
public:
  ExampleOrderBook(const std::string& symbol);
  const std::string& symbol() const;

private:
  std::string symbol_;
};

} } // End namespace
</pre>

<h3>Mapping from Symbol to Order Book</h3>

<p>
  The <code>examples::ExampleOrderBook</code> class manages the order book and
  depth for a single security.  Somewhere the example exchange needs to create
  an order book for each security, and maintain a mapping from symbol to its 
  order book.  This is done in the <code>examples::Exchange</code> class:
</p>

<div class="listing">Listing 6 example_order_book.h: Exchange class in example exchange</div>
<pre class="code">
namespace liquibook { namespace examples {

class Exchange {
public:
  Exchange(ExampleOrderBook::TypedDepthListener* depth_listener,
           ExampleOrderBook::TypedTradeListener* trade_listener);
  void add_order_book(const std::string&amp; symbol);
  void add_order(const std::string&amp; symbol, OrderPtr&amp; order);
private:
  typedef std::map&lt;std::string, ExampleOrderBook&gt; OrderBookMap;
  OrderBookMap order_books_;
  ExampleOrderBook::TypedDepthListener* depth_listener_;
  ExampleOrderBook::TypedTradeListener* trade_listener_;
};

} }
</pre>

<p>
  The implementation of the <code>examples::Exchange</code> class is trivial.
  The constructor saves off the provided listeners, in order to add them to
  future order books:
</p>

<div class="listing">Listing 7 exchange.cpp: Exchange constructor in example exchange</div>
<pre class="code">
namespace liquibook { namespace examples {

Exchange::Exchange(ExampleOrderBook::TypedDepthListener* depth_listener,
                   ExampleOrderBook::TypedTradeListener* trade_listener)
: depth_listener_(depth_listener),
  trade_listener_(trade_listener)
{
}
</pre>

<p>
  The <code>add_order_book()</code> method creates a new order book, sets the
  listeners on the order book, and adds a mapping from the given symbol to the
  order book:
</p>

<div class="listing">Listing 8 exchange.cpp: Exchange method in example exchange</div>
<pre class="code">
void
Exchange::add_order_book(const std::string&amp; sym)
{
  std::pair<OrderBookMap::iterator, bool> result;
  result = order_books_.insert(std::make_pair(sym, ExampleOrderBook(sym)));
  result.first-&gt;second.set_depth_listener(depth_listener_);
  result.first-&gt;second.set_trade_listener(trade_listener_);
}
</pre>

<p>
  Finally, the <code>add_order()</code> method finds the correct order book,
  adds the order to the orer book, and then calls triggers callbacks by calling
  the <code>perform_callbacks()</code> method.
</p>

<div class="listing">Listing 9 exchange.cpp: Exchange method in example exchange</div>
<pre class="code">
void
Exchange::add_order(const std::string&amp; symbol, OrderPtr&amp; order)
{
  OrderBookMap::iterator order_book = order_books_.find(symbol);
  if (order_book != order_books_.end()) {
    order_book-&gt;second.add(order);
    order_book-&gt;second.perform_callbacks();
  }
}

} } // End namespace
</pre>

<h3>Setting up the Exchange</h3>

<p>
  The exchange is initialized in the file <code>publisher_main.cpp</code>.
  The <code>main()</code> function starts by establishing the securities to
  "trade" in our exchange - in this case the NASDAQ 100 - taken from a snapshot 
  in April 2013.  <code>main()</code> records the symbol and a base price in
  a structure:
</p>

<div class="listing">Listing 10 publisher_main.cpp: SecurityInfo structure of example exchange</div>
<pre class="code">
struct SecurityInfo {
  std::string symbol;
  double ref_price;

  SecurityInfo(const char* sym, double price)
  : symbol(sym),
    ref_price(price)
  {
  }
};
</pre>

<p>
  The base price serves as a basis for generating random prices for the
  example exchange.  <code>main()</code> keeps this security information in a
  vector and populates it in a method, called <code>create_securities()</code>:
</p>

<div class="listing">Listing 11 publisher_main.cpp: main() function of example exchange</div>
<pre class="code">
int main(int argc, const char* argv[])
{
  SecurityVector securities;

  // Create securities
  create_securities(securities);
</pre>

<p>
  The body of <code>create_securities()</code> is not shown here, but it adds
  each of the one hundred constituents of the NASDAQ-100 to the vector.  These
  are later added to the exchange, and also referenced while generating random
  orders.
</p>

<h3>Listening for Client Connections</h3>

<p>
  An exchange must accept connections from feed clients in order to 
  disseminate market data to them.  The example exchange does this through a
  class called <code>DepthFeedConnection</code>:
</p>

<h3>Generating Random Orders</h3>

<div class="listing">Listing 12 publisher_main.cpp: main() function (continued) of example exchange</div>
<pre class="code">
  // Feed connection
  examples::DepthFeedConnection connection(argc, argv);

  // Open connection in background thread
  connection.accept();
  boost::function<void ()> acceptor(
      boost::bind(&amp;examples::DepthFeedConnection::run, &amp;connection));
  boost::thread acceptor_thread(acceptor);
</pre>

<p>
  The example exchange creates an instance of <code>DepthFeedConnection</code>,
  passing in the command-line arguments to configure it.  The command line
  arguments it looks for a -t to define the location of the template file, -h
  to set the host to connect to, and -p to set the connection port.
</p>

<p>
  The e
</p>

<h3>Handling Trade Events</h3>

<p>
</p>

<h3>Handling Order Book Events</h3>

<p>
</p>

<h3></h3>
<h3></h3>

<h3>The Feed Protocol</h3>

<p>
  To transmit messages using the FAST protocol, one must first decide on the 
  messages to transmit on the feed.  This exchange will produce a trade feed
  and an incremental depth feed.  The trade messages include:
</p>

<ul>
  <li>Message Type - an indicator that this message is a trade, rather than a
      depth update.</li>
  <li>Sequence Number - so the client can be confident it has received all
      messages, and in the correct order.</li>
  <li>Timestamp - so the client can be confident the message has been received
      in a timely manner.</li>
  <li>Symbol - the symbol of the security which has traded.</li>
  <li>Quantity - the number of shares traded.</li>
  <li>Cost - the total value of the trade.</li>
</ul>

<p>
  QuickFAST uses XML files, called templates to describe the messages in the 
  feed protocol.  The example's templates can be found in the file 
  <code>examples/depth_feed_publisher/depth.xml</code>.  The trade message 
  template looks like this:
</p>

<pre class="code">
&lt;template name="Trade" id="1"&gt;
  &lt;uInt16 name="MessageType" id="100"&gt;
    &lt;constant value="22"/&gt;
  &lt;/uInt16&gt;
  &lt;uInt32 name="SequenceNumber" id="200"&gt;
    &lt;increment/&gt;
  &lt;/uInt32&gt;
  &lt;uInt32 name="Timestamp" id="300"&gt;
    &lt;copy/&gt;
  &lt;/uInt32&gt;
  &lt;string name="Symbol" id="400"&gt;
    &lt;copy/&gt;
  &lt;/string&gt;
  &lt;uInt32 name="Quantity" id="604"&gt;
    &lt;copy/&gt;
  &lt;/uInt32&gt;
  &lt;uInt32 name="Cost" id="603"&gt;
    &lt;copy/&gt;
  &lt;/uInt32&gt;
&lt;/template&gt;
</pre>

<p>
  Note that the tag names within the <code>template</code> tag indicate the type
  of the field.  The reader may be surprised to see a currency field (Cost) 
  represented as an integer (uint32).  This, however is consistent with
  Liquibook's internal storage of prices as as integer.  Using this scheme,
  prices are converted to integer, by shifting the decimal point, so that no
  floating point comparisons need be done in the order book.  This protocol
  carries this design decision forward to the feed protocol, requiring the
  clients to convert these prices back to their decimal format.
</p>

<p>
  The depth update template is more complicated:
</p>

<pre class="code">
&lt;template name="Depth" id="2"&gt;
  &lt;uInt16 name="MessageType" id="100"&gt;
    &lt;constant value="11"/&gt;
  &lt;/uInt16&gt;
  &lt;uInt32 name="SequenceNumber" id="200"&gt;
    &lt;increment/&gt;
  &lt;/uInt32&gt;
  &lt;uInt32 name="Timestamp" id="300"&gt;
    &lt;copy/&gt;
  &lt;/uInt32&gt;
  &lt;string name="Symbol" id="400"&gt;
    &lt;copy/&gt;
  &lt;/string&gt;
  &lt;sequence name="Bids" id="500"&gt;
    &lt;uInt8 name="LevelNum" id="501"&gt;
      &lt;copy/&gt;
    &lt;/uInt8&gt;
    &lt;uInt32 name="OrderCount" id="502"&gt;
      &lt;copy/&gt;
    &lt;/uInt32&gt;
    &lt;uInt32 name="Price" id="503"&gt;
      &lt;copy/&gt;
    &lt;/uInt32&gt;
    &lt;uInt32 name="AggregateQty" id="504"&gt;
      &lt;copy/&gt;
    &lt;/uInt32&gt;
  &lt;/sequence&gt;
  &lt;sequence name="Asks" id="600"&gt;
    &lt;uInt8 name="LevelNum" id="601"&gt;
      &lt;copy/&gt;
    &lt;/uInt8&gt;
    &lt;uInt32 name="OrderCount" id="602"&gt;
      &lt;copy/&gt;
    &lt;/uInt32&gt;
    &lt;uInt32 name="Price" id="603"&gt;
      &lt;copy/&gt;
    &lt;/uInt32&gt;
    &lt;uInt32 name="AggregateQty" id="604"&gt;
      &lt;copy/&gt;
    &lt;/uInt32&gt;
  &lt;/sequence&gt;
&lt;/template&gt;
</pre>

<p>
  The depth message begins with the same 4 fields as the trade message: 
  message type, sequence number, timestamp, and symbol.  The depth message also
  includes two sequences, or  variable-length lists.  These sequences represent 
  the changed bid and ask levels of the depth for the message security.  The
  sequences themselves contain a set of fields, although in this case both
  sequences are of the same type.
</p>

<p>
  The changed depth level begins with a level number, indicating which level 
  has changed.  If the exchange were to produce all depth levels on every 
  change, this would not be necessary.  Since the sequence element could 
  represent any of the 5 levels in an incremental feed, it is required.
</p>

<p>
  Order count indicates the number of orders which were aggregated at this 
  level.  If the order count is 0, it indicates a deleted level.
</p>

<p>
  Price is the price common to all the aggregated orders at this level.  As in
  the trade message, it is represented by an integer.
</p>

<p>
  Finally, aggregate quantity shows the sum of all the order quantities at this
  level.
</p>

<p>
</p>

<p>
    Here is an example of using some code in a sentence. When using the
    <code>String</code> class, be sure to use <code>equals()</code>
    instead of <code>=</code> when comparing two strings.
</p>

<p>
    See <a href="http://sett.ociweb.com/sett/settOct2012.html">October 2012 SETT article</a> for
    an example of displaying code. This method displays line numbers and handles multiple languages.
</p>

<p>
    Make sure to put all referenced files used by the article in a folder called settMmmYyyy_files where Mmm is the
    article month and Yyyy is the article year. For example, settOct2012_files.
</p>

<p>
    Also, make sure your article contains standard ascii characters. Use ", ', - instead of
    forward/backward quotes or ticks. Microsoft word replaces these characters by default. Please
    ensure your article encode these characters properly.
</p>
<table border="2" cellpadding="2" cellspacing="5">
    <tr>
        <th>Bad Example</th>
        <th>Good Example</th>
    </tr>
    <tr>
        <td>“example quotes”</td>
        <td>&#8220;example quotes&#8221;</td>
    </tr>
    <tr>
        <td>‘another example’</td>
        <td>&#8216;another example&#8217;</td>
    </tr>
    <tr>
        <td>hyphens – anyone?</td>
        <td>hyphens &#8212; anyone?</td>
    </tr>
    <tr>
        <td>dot dot dot</td>
        <td>dot dot dot &#8230;</td>
    </tr>
</table>

<p>
    If you need to use these, be sure to use the appropriate unicode escape sequence.
</p>

<h2>Final Big Topic</h2>

<p>
    Here is how to include blocks of code in the article using the &lt;pre&gt; tag and syntax highlighter:
</p>

<pre class="brush: java">
    import java.io.*;

    public class Foobar extends Whatever {
        public static void main(String[] args) {
            <span class="green">// 4-space indent according to JavaSoft conventions</span>
        }
    }
</pre>

<p>Now describe the code.</p>

<h2>Summary</h2>

<p>
    Wrap things up.
</p>

<p>
    Tip: avoid &amp;nbsp; for indentation. When specific indentation is
    required (usually for code examples), use a &lt;pre&gt; block
    instead.
</p>

<h2>References</h2>

<p>
    Providing references is a good idea. Be sure to spell out the URLs,
    including the protocol, so people can print the article and see the
    addresses.
</p>
<ul>
    <li>Liquibook -
        <a href="https://github.com/objectcomputing/liquibook" shape="rect">https://github.com/objectcomputing/liquibook</a>
    </li>
    <li>QuickFAST -
        <a href="http://quickfast.org" shape="rect">http://quickfast.org</a>
    </li>
    <li>FIX protocol -
        <a href="http://www.fixprotocol.org" shape="rect">http://www.fixprotocol.org</a>
    </li>
    <li>FAST protocol -
        <a href="http://www.fixprotocol.org/fast" shape="rect">http://www.fixprotocol.org/fast</a>
    </li>
    <li>NASDAQ 100 -
        <a href="http://www.nasdaq.com/markets/indices/nasdaq-100.aspx" shape="rect">http://www.nasdaq.com/markets/indices/nasdaq-100.aspx</a>
    </li>
    <li>Other -
        <a href="" shape="rect"></a>
    </li>
</ul>

<hr/>
<p class="footer">
    <strong>Object Computing, Inc.</strong> is located in
    St. Louis, MO and a Member of the Object Management
    Group, OMG. OCI specializes in distributed computing using
    object-oriented and web-enabled technologies and provides
    <a href="http://www.ociweb.com/consulting/index.html">Consulting</a>,
    <a href="http://www.ociweb.com/education/index.html">Education</a>,
    <a href="http://www.ociweb.com/solution-engineering/index.html">Solutions Engineering</a>
    and
    <a href="http://www.ociweb.com/product/index.html">Open Source Development/Support</a>
    services to clients nation-wide. For more information contact us in
    St. Louis, MO (314)579-0066, Tempe, AZ (480)752-0042 or email
    <a href="mailto:info@ociweb.com">info@ociweb.com</a>.
</p>
<p class="footer">
    Inquiries regarding
    <a class="career" href="http://www.ociweb.com/careers/index.html">Career Opportunities</a>
    can be directed to: <a href="mailto:hr@ociweb.com">hr@ociweb.com</a>.
</p>
<p class="footer">
    The <em><strong>Software Engineering Tech Trends</strong></em>
    is a monthly newsletter. The purpose and intent of this publication is to
    partner with clients in developing solutions for their most demanding mission critical
    systems, by leveraging our deep experience in software and systems engineering. We promote
    non-proprietary, standards-based solutions that afford our clients greater control and
    broader choice. Knowledge transfer is a fundamental aspect of services we offer our customers.
    We tailor our engagements to meet customer needs. We foster the professional growth of our
    employees and reward excellence.

    To
    <a href="mailto:sett-join@ociweb.com">subscribe</a>
    or
    <a href="mailto:sett-leave@ociweb.com">unsubscribe</a>
</p>
<p class="footer">
    Copyright
    &copy;2008-2013.
    Object Computing, Inc. All rights reserved.<br/>
    <br/>Java and all
    Java-based marks are trademarks or registered trademarks of Oracle Corporation.<br/>
    <br/>
    .NET, C#, and .NET-based marks are trademarks or registered trademarks of Microsoft
    Corporation.
</p>
<div style="margin-top: 25px">
    <div style="float:left">
        <a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10"
                                                                 alt="Valid XHTML 1.0 Strict" height="31" width="88"/></a>
    </div>
    <div style="float:right">
        <a href="#top">Top</a>
    </div>
</div>

<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shAutoloader.js" type="text/javascript"></script>

<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js" type="text/javascript"></script>

<script type="text/javascript">SyntaxHighlighter.all()</script>

</body>
</html>
